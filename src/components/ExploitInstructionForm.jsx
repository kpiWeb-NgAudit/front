// src/components/ExploitInstructionForm.jsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    EXP_INS_TYPES, EXP_INS_SPE_PLACES, EXP_INS_ANTEPOST_SPE_OPTIONS,
    getBooleanStringOptions, getDropdownOptions
} from '../constants/exploitInstructionEnums';
import {getAllCustomers} from "../api/customerService.js";


const snakeToPascal = (str) => {
    if (!str) return str;
    if (str.toLowerCase().endsWith("_pk")) {
        const prefix = str.substring(0, str.length - 3);
        return prefix.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('') + 'Pk';
    }
    let s = str.startsWith("expIns_") ? str.substring(7) : str; // Handle "expIns_" prefix
    s = s.startsWith("cube_") ? s.substring(5) : s; // Handle "cube_" prefix
    return s.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('');
};


const ExploitInstructionForm = ({ onSubmit, onCancel, initialData = {}, parentCubeIdPk, isEditMode = false }) => {

    const [customers, setCustomers] = useState([]); // <<< NEW STATE
    const [loadingCustomers, setLoadingCustomers] = useState(false); // <<< NEW STATE

    const getInitialFormState = useCallback(() => ({
        ExpInsIdPk: '',
        ExpInsType: EXP_INS_TYPES[0] || '',
        ExpInsSpePlace: EXP_INS_SPE_PLACES[0] || '',
        ExpInsAntePostSpe: EXP_INS_ANTEPOST_SPE_OPTIONS[0] || '',
        ExpInsSortOrder: 0,
        ExpInsActive: "true", // Default to true (string for select)
        ExpInsObjectMessage: '',
        ExpInsTextMessage: '',
        ExpInsSendTo: '',
        ExpInsCopyTo: '',
        ExpInsNbLinesTrigger: 0,
        ExpInsTextSqlResult: "false", // Default to false
        ExpInsAttachResult: "false", // Default to false
        ExpInsSqlInstruction: '',
        CubeIdPk: parentCubeIdPk || '',
        ExpInsComments: '',
        ExpInsTimestamp: null,
    }), [parentCubeIdPk]);

    const [formData, setFormData] = useState(getInitialFormState);
    const [errors, setErrors] = useState({});


    // Fetch customers if adding globally and no parentCubeIdPk
    useEffect(() => {
        if (!isEditMode && !parentCubeIdPk) {
            setLoadingCustomers(true);
            getAllCustomers({ pageSize: 1000 })
                .then(response => setCustomers(Array.isArray(response) ? response : []))
                .catch(err => {
                    setErrors(prev => ({...prev, customersDropdown: "Failed to load customers"}));
                    setCustomers([]);
                })
                .finally(() => setLoadingCustomers(false));
        } else {
            setLoadingCustomers(false); setCustomers([]);
        }
    }, [isEditMode, parentCubeIdPk]);


    useEffect(() => {
        let populatedState = getInitialFormState();
        if (isEditMode && initialData && Object.keys(initialData).length > 0) {
            populatedState = { ...populatedState };
            for (const backendKey in initialData) {
                if (initialData.hasOwnProperty(backendKey)) {
                    const formKey = snakeToPascal(backendKey); // Convert expIns_type to ExpInsType
                    if (populatedState.hasOwnProperty(formKey)) {
                        const value = initialData[backendKey];
                        if (value === null || typeof value === 'undefined') {
                            populatedState[formKey] = '';
                        } else if (typeof value === 'boolean') {
                            populatedState[formKey] = String(value); // "true" or "false"
                        } else if (typeof value === 'number') {
                            populatedState[formKey] = String(value);
                        } else if (formKey === 'ExpInsTimestamp' && value) {
                            populatedState[formKey] = value;
                        } else {
                            populatedState[formKey] = value;
                        }
                    }
                }
            }
            if (initialData.expIns_id_pk !== undefined) populatedState.ExpInsIdPk = String(initialData.expIns_id_pk);
            if (initialData.cube_id_pk !== undefined) populatedState.CubeIdPk = String(initialData.cube_id_pk);
        }
        setFormData(populatedState);
        setErrors({});
    }, [initialData, isEditMode, getInitialFormState, parentCubeIdPk]);


    const validate = () => {
        const newErrors = {};
        if (!isEditMode && (formData.ExpInsIdPk === '' || isNaN(parseInt(formData.ExpInsIdPk)) || parseInt(formData.ExpInsIdPk) <= 0 )) {
            newErrors.ExpInsIdPk = 'Instruction ID is required and must be a positive number.';
        }
        if (!formData.ExpInsType) newErrors.ExpInsType = 'Type is required.';
        if (!formData.ExpInsSpePlace) newErrors.ExpInsSpePlace = 'Execution Place is required.';
        if (!formData.ExpInsAntePostSpe) newErrors.ExpInsAntePostSpe = 'Ante/Post Spe is required.';
        if (formData.ExpInsSortOrder === '' || isNaN(parseInt(formData.ExpInsSortOrder))) {
            newErrors.ExpInsSortOrder = 'Sort Order must be a number.';
        }
        if (!formData.ExpInsActive) newErrors.ExpInsActive = 'Active status is required.'; // Should be "true" or "false"
        if (!formData.ExpInsObjectMessage.trim()) newErrors.ExpInsObjectMessage = 'Object/Message is required.';
        else if(formData.ExpInsObjectMessage.length > 80) newErrors.ExpInsObjectMessage = 'Object/Message max 80 chars.';
        if (!formData.ExpInsTextMessage.trim()) newErrors.ExpInsTextMessage = 'Text Message is required.';
        if (formData.ExpInsSendTo && formData.ExpInsSendTo.length > 120) newErrors.ExpInsSendTo = 'Send To max 120 chars.';
        if (formData.ExpInsCopyTo && formData.ExpInsCopyTo.length > 360) newErrors.ExpInsCopyTo = 'Copy To max 360 chars.';
        if (formData.ExpInsNbLinesTrigger === '' || isNaN(parseInt(formData.ExpInsNbLinesTrigger))) {
            newErrors.ExpInsNbLinesTrigger = 'Nb Lines Trigger must be a number.';
        }
        if (!formData.ExpInsTextSqlResult) newErrors.ExpInsTextSqlResult = 'Text SQL Result option is required.';
        if (!formData.ExpInsAttachResult) newErrors.ExpInsAttachResult = 'Attach Result option is required.';
        if (!formData.ExpInsSqlInstruction.trim()) newErrors.ExpInsSqlInstruction = 'SQL Instruction is required.';
        if (!formData.CubeIdPk) newErrors.CubeIdPk = 'Parent Customer ID is missing.';

        if (isEditMode && !formData.ExpInsTimestamp) newErrors.form = "Timestamp missing for update.";
        setErrors(newErrors);
        return Object.keys(newErrors).length === 0;
    };

    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
        if(errors[name]) setErrors(prev => ({...prev, [name]: null}));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!validate()) {
            setErrors(prev => ({...prev, form: "Please correct errors."}));
            return;
        }
        const submissionData = {
            ExpInsType: formData.ExpInsType,
            ExpInsSpePlace: formData.ExpInsSpePlace,
            ExpInsAntePostSpe: formData.ExpInsAntePostSpe,
            ExpInsSortOrder: parseInt(formData.ExpInsSortOrder, 10),
            ExpInsActive: formData.ExpInsActive === "true", // Convert string "true"/"false" to boolean
            ExpInsObjectMessage: formData.ExpInsObjectMessage.trim(),
            ExpInsTextMessage: formData.ExpInsTextMessage.trim(),
            ExpInsSendTo: formData.ExpInsSendTo.trim() === '' ? null : formData.ExpInsSendTo.trim(),
            ExpInsCopyTo: formData.ExpInsCopyTo.trim() === '' ? null : formData.ExpInsCopyTo.trim(),
            ExpInsNbLinesTrigger: parseInt(formData.ExpInsNbLinesTrigger, 10),
            ExpInsTextSqlResult: formData.ExpInsTextSqlResult === "true",
            ExpInsAttachResult: formData.ExpInsAttachResult === "true",
            ExpInsSqlInstruction: formData.ExpInsSqlInstruction.trim(),
            CubeIdPk: formData.CubeIdPk,
            ExpInsComments: formData.ExpInsComments.trim() === '' ? null : formData.ExpInsComments.trim(),
        };

        if (!isEditMode) {
            submissionData.ExpInsIdPk = parseInt(formData.ExpInsIdPk, 10);
        } else {
            if (!formData.ExpInsTimestamp) { /* Error handled in validate */ return; }
            submissionData.ExpInsTimestamp = formData.ExpInsTimestamp;
        }

        try {
            await onSubmit(submissionData);
        } catch (error) { /* ... error handling as in other forms ... */
            const errorMsg = error.response?.data?.message || error.response?.data?.title || error.message || 'Submission failed.';
            setErrors(prev => ({ ...prev, form: errorMsg }));
            if (error.response?.data?.errors) {
                const backendFieldErrors = {};
                for (const key in error.response.data.errors) {
                    backendFieldErrors[snakeToPascal(key)] = error.response.data.errors[key].join(', ');
                }
                setErrors(prev => ({ ...prev, ...backendFieldErrors }));
            }
        }
    };
    const boolToString = (val) => val === null || val === undefined ? "" : String(val);


    return (
        <form onSubmit={handleSubmit} className="exploit-instruction-form" style={{ border: '1px solid #ccc', padding: '15px', marginTop: '10px', marginBottom: '20px' }}>
            <h4>{isEditMode ? `Edit Instruction (ID: ${formData.ExpInsIdPk || (initialData && initialData.expIns_id_pk)})` : 'Add New Exploit Instruction'}</h4>
            {errors.form && <p className="error-message" style={{color: 'red', fontWeight: 'bold'}}>{errors.form}</p>}

            {/* Customer Selector/Display Logic */}
            {!isEditMode && !parentCubeIdPk && (
                <div className="form-group">
                    <label htmlFor="CubeIdPkExploitForm">Parent Customer (*)</label>
                    {loadingCustomers ? <p>Loading customers...</p> : (
                        <select id="CubeIdPkExploitForm" name="CubeIdPk" value={formData.CubeIdPk} onChange={handleChange} required>
                            <option value="">--- Select Customer ---</option>
                            {customers.map(c => <option key={c.cube_id_pk} value={c.cube_id_pk}>{c.cube_name} ({c.cube_id_pk})</option>)}
                        </select>
                    )}
                    {errors.CubeIdPk && <p className="error-message">{errors.CubeIdPk}</p>}
                    {errors.customersDropdown && <p className="error-message">{errors.customersDropdown}</p>}
                </div>
            )}
            {(isEditMode || parentCubeIdPk) && (
                <div className="form-group">
                    <label>Parent Customer</label>
                    <input type="text" value={formData.CubeIdPk} readOnly disabled placeholder={parentCubeIdPk || (initialData && initialData.cube_id_pk) || "N/A"} />
                </div>
            )}


            <fieldset>
                <legend>Instruction Core Details</legend>
                <div className="form-group">
                    <label htmlFor="ExpInsIdPkForm">Instruction ID (*)</label>
                    <input type="number" id="ExpInsIdPkForm" name="ExpInsIdPk" value={formData.ExpInsIdPk} onChange={handleChange} required readOnly={isEditMode} />
                    {errors.ExpInsIdPk && <p className="error-message">{errors.ExpInsIdPk}</p>}
                </div>
                <div className="form-group">
                    <label htmlFor="ExpInsTypeForm">Type (*)</label>
                    <select id="ExpInsTypeForm" name="ExpInsType" value={formData.ExpInsType} onChange={handleChange} required>
                        {getDropdownOptions(EXP_INS_TYPES).map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                    </select>
                    {errors.ExpInsType && <p className="error-message">{errors.ExpInsType}</p>}
                </div>
                <div className="form-group">
                    <label htmlFor="ExpInsSpePlaceForm">Execution Place (*)</label>
                    <select id="ExpInsSpePlaceForm" name="ExpInsSpePlace" value={formData.ExpInsSpePlace} onChange={handleChange} required>
                        {getDropdownOptions(EXP_INS_SPE_PLACES).map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                    </select>
                    {errors.ExpInsSpePlace && <p className="error-message">{errors.ExpInsSpePlace}</p>}
                </div>
                <div className="form-group">
                    <label htmlFor="ExpInsAntePostSpeForm">Ante/Post Spe (*)</label>
                    <select id="ExpInsAntePostSpeForm" name="ExpInsAntePostSpe" value={formData.ExpInsAntePostSpe} onChange={handleChange} required>
                        {getDropdownOptions(EXP_INS_ANTEPOST_SPE_OPTIONS).map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                    </select>
                    {errors.ExpInsAntePostSpe && <p className="error-message">{errors.ExpInsAntePostSpe}</p>}
                </div>
                <div className="form-group">
                    <label htmlFor="ExpInsSortOrderForm">Sort Order (*)</label>
                    <input type="number" id="ExpInsSortOrderForm" name="ExpInsSortOrder" value={formData.ExpInsSortOrder} onChange={handleChange} required />
                    {errors.ExpInsSortOrder && <p className="error-message">{errors.ExpInsSortOrder}</p>}
                </div>
                <div className="form-group">
                    <label htmlFor="ExpInsActiveForm">Active (*)</label>
                    <select id="ExpInsActiveForm" name="ExpInsActive" value={boolToString(formData.ExpInsActive)} onChange={handleChange} required>
                        {/* Using "true"/"false" strings for boolean select values */}
                        {getBooleanStringOptions("Active", "Inactive").map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                    </select>
                    {errors.ExpInsActive && <p className="error-message">{errors.ExpInsActive}</p>}
                </div>
            </fieldset>

            <fieldset>
                <legend>Message & Notification Content</legend>
                <div className="form-group">
                    <label htmlFor="ExpInsObjectMessageForm">Object/Subject (*)</label>
                    <input type="text" id="ExpInsObjectMessageForm" name="ExpInsObjectMessage" value={formData.ExpInsObjectMessage} onChange={handleChange} maxLength="80" required />
                    {errors.ExpInsObjectMessage && <p className="error-message">{errors.ExpInsObjectMessage}</p>}
                </div>
                <div className="form-group">
                    <label htmlFor="ExpInsTextMessageForm">Text Message (Body) (*)</label>
                    <textarea id="ExpInsTextMessageForm" name="ExpInsTextMessage" value={formData.ExpInsTextMessage} onChange={handleChange} required rows="4" />
                    {errors.ExpInsTextMessage && <p className="error-message">{errors.ExpInsTextMessage}</p>}
                </div>
                <div className="form-group">
                    <label htmlFor="ExpInsSendToForm">Send To (Emails, comma-separated)</label>
                    <input type="text" id="ExpInsSendToForm" name="ExpInsSendTo" value={formData.ExpInsSendTo} onChange={handleChange} maxLength="120" placeholder="e.g., email1@example.com, email2@example.com"/>
                    {errors.ExpInsSendTo && <p className="error-message">{errors.ExpInsSendTo}</p>}
                </div>
                <div className="form-group">
                    <label htmlFor="ExpInsCopyToForm">Copy To (Emails, comma-separated)</label>
                    <input type="text" id="ExpInsCopyToForm" name="ExpInsCopyTo" value={formData.ExpInsCopyTo} onChange={handleChange} maxLength="360" />
                    {errors.ExpInsCopyTo && <p className="error-message">{errors.ExpInsCopyTo}</p>}
                </div>
            </fieldset>

            <fieldset>
                <legend>Trigger Conditions & SQL Action</legend>
                <div className="form-group">
                    <label htmlFor="ExpInsNbLinesTriggerForm">Nb Lines Trigger (*)</label>
                    <input type="number" id="ExpInsNbLinesTriggerForm" name="ExpInsNbLinesTrigger" value={formData.ExpInsNbLinesTrigger} onChange={handleChange} required min="0" />
                    {errors.ExpInsNbLinesTrigger && <p className="error-message">{errors.ExpInsNbLinesTrigger}</p>}
                </div>
                <div className="form-group">
                    <label htmlFor="ExpInsTextSqlResultForm">Include SQL Result in Text (*)</label>
                    <select id="ExpInsTextSqlResultForm" name="ExpInsTextSqlResult" value={boolToString(formData.ExpInsTextSqlResult)} onChange={handleChange} required>
                        {getBooleanStringOptions().map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                    </select>
                    {errors.ExpInsTextSqlResult && <p className="error-message">{errors.ExpInsTextSqlResult}</p>}
                </div>
                <div className="form-group">
                    <label htmlFor="ExpInsAttachResultForm">Attach SQL Result File (*)</label>
                    <select id="ExpInsAttachResultForm" name="ExpInsAttachResult" value={boolToString(formData.ExpInsAttachResult)} onChange={handleChange} required>
                        {getBooleanStringOptions().map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
                    </select>
                    {errors.ExpInsAttachResult && <p className="error-message">{errors.ExpInsAttachResult}</p>}
                </div>
                <div className="form-group">
                    <label htmlFor="ExpInsSqlInstructionForm">SQL Instruction (*)</label>
                    <textarea id="ExpInsSqlInstructionForm" name="ExpInsSqlInstruction" value={formData.ExpInsSqlInstruction} onChange={handleChange} required rows="6" style={{ fontFamily: 'monospace', whiteSpace: 'pre', overflowWrap: 'normal', overflowX: 'scroll' }} />
                    {errors.ExpInsSqlInstruction && <p className="error-message">{errors.ExpInsSqlInstruction}</p>}
                </div>
            </fieldset>

            <fieldset>
                <legend>Comments (Optional)</legend>
                <div className="form-group">
                    <label htmlFor="ExpInsCommentsForm">Comments</label>
                    <textarea id="ExpInsCommentsForm" name="ExpInsComments" value={formData.ExpInsComments} onChange={handleChange} rows="3" />
                    {errors.ExpInsComments && <p className="error-message">{errors.ExpInsComments}</p>}
                </div>
            </fieldset>

            <div className="form-actions" style={{ marginTop: '20px' }}>
                <button type="submit" className="primary">{isEditMode ? 'Update Instruction' : 'Add Instruction'}</button>
                <button type="button" className="secondary" onClick={onCancel} style={{ marginLeft: '10px' }}>Cancel</button>
            </div>
        </form>
    );
};

export default ExploitInstructionForm;